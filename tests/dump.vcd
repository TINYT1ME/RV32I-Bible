$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module $rootio $end
  $var wire 1 # clk $end
  $var wire 1 $ resetn $end
  $var wire 32 % pc_out [31:0] $end
  $var wire 32 & instr_out [31:0] $end
  $var wire 32 ' pc_pl_out [31:0] $end
  $var wire 32 ( instr_pl_out [31:0] $end
 $upscope $end
 $scope module cpu_top $end
  $var wire 1 ) clk $end
  $var wire 1 * resetn $end
  $var wire 32 + pc_out [31:0] $end
  $var wire 32 , instr_out [31:0] $end
  $var wire 32 - pc_pl_out [31:0] $end
  $var wire 32 . instr_pl_out [31:0] $end
  $scope module fetch_pipeline $end
   $var wire 1 / clk $end
   $var wire 1 0 resetn $end
   $var wire 32 1 pc_in [31:0] $end
   $var wire 32 2 im_in [31:0] $end
   $var wire 32 3 pc_pl_out [31:0] $end
   $var wire 32 4 im_pl_out [31:0] $end
  $upscope $end
  $scope module im_inst $end
   $var wire 1 5 resetn $end
   $var wire 32 6 read_addr [31:0] $end
   $var wire 32 7 instr_out [31:0] $end
   $var wire 32 = MEM_SIZE [31:0] $end
   $var wire 32 8 k [31:0] $end
  $upscope $end
  $scope module pc_inst $end
   $var wire 1 9 clk $end
   $var wire 1 : resetn $end
   $var wire 32 ; pc_out [31:0] $end
   $var wire 32 < next_pc [31:0] $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
1#
0$
b00000000000000000000000000000000 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 (
1)
0*
b00000000000000000000000000000000 +
b00000000000000000000000000000000 ,
b00000000000000000000000000000000 -
b00000000000000000000000000000000 .
1/
00
b00000000000000000000000000000000 1
b00000000000000000000000000000000 2
b00000000000000000000000000000000 3
b00000000000000000000000000000000 4
05
b00000000000000000000000000000000 6
b00000000000000000000000000000000 7
b00000000000000000000000000000000 8
19
0:
b00000000000000000000000000000000 ;
b00000000000000000000000000000100 <
b00000000000000000000000100000000 =
#140000
